
shinyServer(function(input, output, session) {
  
  library(ggplot2)
  library(dplyr)
  
  options(shiny.maxRequestSize = 5000*1024^2) # allow upload of files with max 5GB
  
  ###############################################################
  # 0. Global variables and functions
  ###############################################################
  
  #Initializating user experience functions
  js$init_directory() #Getting cookie for the directory
 
  # addResourcePath("www", system.file("www", package="ChromSCape"))
  tab_vector = c("pca_plots",
                 "cor_clustering",
                 "cons_clustering",
                 "peak_calling",
                 "diff_analysis",
                 "enrich_analysis") #list of all lockable tabs
  unlocked = reactiveValues(list = list(selected_reduced_dataset = FALSE,
                                        pca = FALSE,
                                        tsne = FALSE,
                                        cor_clust_plot = FALSE,
                                        filtered_datasets = FALSE,
                                        affectation = FALSE,
                                        diff_my_res = FALSE)) #list of all required items to unlock a tab
  for(tab in tab_vector){
    js$disableTab(tab) #Disabling all tabs but the first one
  }
  
  #Global reactives values
  scExp = reactiveVal(NULL)
  scExp_cf = reactiveVal(NULL)
  
  cell_cov_df <- reactive ({data.frame(coverage = sort(unname(Matrix::colSums(init$datamatrix)))) })  # used for plotting cell coverage on first page
  dataset_name <- reactive({ sub("_\\d+_\\d+(\\.\\d+)?_\\d+_[A-z]+$", "", input$selected_reduced_dataset) })
  annotation_id_norm <- reactive({ read.table(file.path(init$data_folder, 'datasets', input$selected_raw_dataset, 'annotation.txt'), header = FALSE, stringsAsFactors = FALSE)[[1]] })
  annotation_id <- reactive({ read.table(file.path(init$data_folder, 'datasets', dataset_name(), 'annotation.txt'), header = FALSE, stringsAsFactors = FALSE)[[1]] })
  
  #Global Functions
  init <- reactiveValues(data_folder =  getwd(), datamatrix = data.frame(), annot_raw = data.frame(), available_raw_datasets = NULL,
                         available_reduced_datasets = NULL, available_filtered_datasets = NULL)
  reduced_datasets <- reactive({ if (is.null(init$available_reduced_datasets)) c() else gsub('.{6}$', '', basename(init$available_reduced_datasets)) })
  
  annotCol <- reactive({ c("sample_id","total_counts","batch_id") })
  
  
  observeEvent(dataset_name(), { # application header (tells you which data set is selected)
    req(dataset_name())
    header <- paste0('Sample : ', dataset_name())
    shinyjs::html("pageHeader", header)
  })
  
  get.available.reduced.datasets <- function(){
    list.files(path = file.path(init$data_folder, "datasets"), full.names = FALSE, recursive = TRUE,
               pattern="[[:print:]]+_[[:digit:]]+_[[:digit:]]+(.[[:digit:]]+)?_[[:digit:]]+_(uncorrected|batchCorrected).RData")
  }
  
  get.available.filtered.datasets <- function(name, preproc){
    list.files(path = file.path(init$data_folder, "datasets", name, "correlation_clustering"), full.names = FALSE, recursive = FALSE, pattern = paste0(preproc, "_[[:digit:]]+_[[:digit:]]+(.[[:digit:]]+)?.RData"))
  }
  
  able_disable_tab <- function(variables_to_check, tab_id) {
    able_or_disable = c()
    for(var in variables_to_check){
      if (unlocked$list[[var]]==T) {
        able_or_disable = c(able_or_disable,TRUE)
      } else{
        able_or_disable = c(able_or_disable,FALSE)
      }}
    for (tab in tab_id) {
      if (FALSE %in% able_or_disable) {
        js$disableTab(tab_id)
      }
      else{
        js$enableTab(tab)
      }}
  }
  
  batchUsed <- reactive({ grepl("batchCorrected", input$selected_reduced_dataset) })
  
  ###############################################################
  # 1. Select or upload dataset
  ###############################################################
  
  output$selected_raw_dataset <- renderUI({ selectInput("selected_raw_dataset", "Select data set :", choices = init$available_raw_datasets) })
  output$data_folder_info <- renderText({"Please select the directory which contains the 'dataset' folder that was built by the app. If this folder does not yet exist, the app will create it in the specified directory."})
  output$selected_reduced_dataset <- renderUI({ selectInput("selected_reduced_dataset", "Select filtered & normalized set :", choices = reduced_datasets()) })
  output$red_data_selection_info <- renderText({"The selected data set is automatically loaded and will be used for all subsequent analysis. If you just filtered a new data set, don't forget to select it here."})
  output$red_data_selection_format <- renderText({"The name of the preprocessed dataset is composed of the following information: data set name, min percentage of reads per cell, min percentage of cells to support a window, quantile of cell read counts to keep"})
  output$data_matrices_info <- renderText({"The filename of each selected matrix must be the sample id, e.g. T23_K4me3.txt (Must contain only alpha-numeric charachter and underscore !)"})
  output$data_deletion_info <- renderText({"The selected data set will be fully deleted from the computer, including all reduced data versions that have been produced so far for this set."})
  output$selected_delete_dataset <- renderUI({ selectInput("selected_delete_dataset", "Select data set :", choices = init$available_raw_datasets) })
  output$exclude_file <- renderUI({ if(input$exclude_regions){
    fileInput("exclude_file", ".bed file containing the regions to exclude from data set:", multiple = FALSE, accept = c(".bed"))
  }})
  output$num_batches <- renderUI({ if(input$do_batch_corr){
    selectInput("num_batches","Select number of batches (each can have one or multiple samples):", choices=c(2:10))
  }})
  output$batch_names <- renderUI({ if(input$do_batch_corr & !is.null(input$num_batches)){
    lapply(1:input$num_batches, function(i){
      textInput(paste0('batch_name_', i), paste0('Batch name ', i, ':'), value = paste0('batch', i))
    })
  }})
  batch_choice <- reactive({ unique(init$annot_raw$sample_id) })
  output$batch_sel <- renderUI({ if(input$do_batch_corr & dim(init$annot_raw)[1] > 0 & !is.null(input$num_batches)){
    lapply(1:input$num_batches, function(i){
      selectInput(paste0('batch_sel_', i), paste0('Select samples for batch ', i, ':'), choices=batch_choice(), multiple=TRUE)
    })
  }})
  
  shinyFiles::shinyDirChoose(
    input,
    'data_folder',
    roots = c(home = '~'),
    filetypes = c('')
  )
  directory <- reactive(input$data_folder)
  output$directory <- renderText({
    init$data_folder
  })
  
  #Look for existing cookie
  observeEvent(
    ignoreNULL = TRUE,
    eventExpr = {
      input$path_cookie
    },
    handlerExpr = {
       if ( (input$path_cookie != "[null]") && !is.null(input$path_cookie) && !is.na(input$path_cookie)) {
          #Uploading the name displayed in Data Folder

          init$data_folder <- normalizePath(gsub(pattern = "\"|\\[|\\]|\\\\", "",as.character(input$path_cookie)))
          print(gsub(pattern = "\"|\\[|\\]|\\\\", "",as.character(input$path_cookie)))
          print(init$data_folder)
          # directory(init$data_folder)
          init$available_raw_datasets <- list.dirs(path = file.path(init$data_folder, "datasets"), full.names = FALSE, recursive = FALSE)
          init$available_reduced_datasets <- get.available.reduced.datasets()
        }
      })
  
  #Selecting a working directory using shinyDirectoryInput::readDirectoryInput(input$data_folder) and saving cookie
  observeEvent(
    ignoreNULL = TRUE,
    eventExpr = {
      input$data_folder  
    },
    handlerExpr = {
      if (!"path" %in% names(directory())) return()
      home <- normalizePath("~")
      print(directory())
      print(directory()$path)
      init$data_folder <-
        file.path(home, paste(unlist(directory()$path[-1]), collapse = .Platform$file.sep))

      init$available_raw_datasets <- list.dirs(path = file.path(init$data_folder, "datasets"), full.names = FALSE, recursive = FALSE)
      init$available_reduced_datasets <- get.available.reduced.datasets()
      js$save_cookie(init$data_folder)
      # if (input$data_folder > 0) {
      #   # launch the directory selection dialog with initial path read from the widget
      #   folder = shinyDirectoryInput::choose.dir() #default = shinyDirectoryInput::readDirectoryInput(session, 'data_folder')
      #   js$save_cookie(folder)
      #   if (!is.na(folder)){
      #     init$data_folder <- folder
      #     init$available_raw_datasets <- list.dirs(path = file.path(init$data_folder, "datasets"), full.names = FALSE, recursive = FALSE)
      #     init$available_reduced_datasets <- get.available.reduced.datasets()
      #     shinyDirectoryInput::updateDirectoryInput(session, 'data_folder', value = folder)
      #     js$save_cookie(folder)
      #   }
      # }
    }
  )
  
  observeEvent(input$compile_dataset, {  # save new dataset
    req(input$new_dataset_name, input$annotation, input$datafile_matrix)
    datamatrix <- NULL
    annot_raw <- NULL
    withProgress(message='Compiling new data set...',value = 0, {
      dir.create(file.path(init$data_folder, "datasets"), showWarnings = FALSE)
      dir.create(file.path(init$data_folder, "datasets", input$new_dataset_name))
      dir.create(file.path(init$data_folder, "datasets", input$new_dataset_name, "QC_filtering"))
      dir.create(file.path(init$data_folder, "datasets", input$new_dataset_name, "correlation_clustering"))
      dir.create(file.path(init$data_folder, "datasets", input$new_dataset_name, "correlation_clustering","Plots"))
      dir.create(file.path(init$data_folder, "datasets", input$new_dataset_name, "diff_analysis_GSEA"))
      write.table(input$annotation, file.path(init$data_folder, 'datasets', input$new_dataset_name, 'annotation.txt'), row.names = FALSE, col.names = FALSE, quote = FALSE)
      incProgress(0.3, detail="reading data matrices")

      for(i in 1:dim(input$datafile_matrix)[1]){
        print(input$datafile_matrix$datapath[i])
        datamatrix_single <- scater::readSparseCounts(input$datafile_matrix$datapath[i], sep="\t")
        gc()
        #perform some checks on data format

        matchingRN <- grep("[[:alnum:]]+(:|_)[[:digit:]]+(-|_)[[:digit:]]+", rownames(datamatrix_single)) # check rowname format
        if(length(matchingRN) < length(rownames(datamatrix_single))){
          showNotification(paste0(input$datafile_matrix$name, " contains ", (length(rownames(datamatrix_single))-length(matchingRN)),
                                  " rownames that do not conform to the required format. Please check your data matrix and try again."),
                           duration = NULL, closeButton = TRUE, type="warning")
          if(length(matchingRN) < 5){ # almost all rownames are wrong
            showNotification("Maybe your rownames are contained in the first column instead? 
                             In this case, remove the header of this column so that they are
                             interpreted as rownames.", duration = NULL, closeButton = TRUE, type="warning")
          }
          unlink(file.path(init$data_folder, "datasets", input$new_dataset_name), recursive = TRUE)
          return()
        }
        
        numericC <- apply(datamatrix_single[1:5,1:5],MARGIN=2,is.numeric) # check if matrix is numeric
        if(sum(numericC) < 5){
          showNotification(paste0(input$datafile_matrix$name, " contains non-numeric columns at the following indices: ", which(numericC==FALSE), ". Please check your data matrix and try again."), duration=NULL, closeButton=TRUE, type="warning")
          unlink(file.path(init$data_folder, "datasets", input$new_dataset_name), recursive=TRUE)
          return()
        }

        if(rownames(datamatrix_single)[1] == "1"){
          names = datamatrix_single$X0
          datamatrix_single = datamatrix_single[,-1]
          rownames(datamatrix_single) = names
        }

        datamatrix_single <- datamatrix_single[!duplicated(rownames(datamatrix_single)),] #put IN for new format

        if(length(grep("chr",rownames(datamatrix_single)[1:10],perl = T)) >= 9){
          rownames(datamatrix_single) <- gsub(":", "_", rownames(datamatrix_single))
          rownames(datamatrix_single) <- gsub("-", "_", rownames(datamatrix_single))
        }
        gc()
        total_cell <- length(datamatrix_single[1,])

        sample_name <- gsub('.{4}$', '', input$datafile_matrix$name[i])
    
        annot_single <- data.frame(barcode = colnames(datamatrix_single),
                                   cell_id = paste0(sample_name, "_c", 1:total_cell),
                                   sample_id = rep(sample_name, total_cell),
                                   batch_id = i)
        colnames(datamatrix_single) <- annot_single$cell_id
        if(is.null(datamatrix)){
          datamatrix <- datamatrix_single
        }else{
          
          common_regions <- intersect(rownames(datamatrix), rownames(datamatrix_single))
          datamatrix <- Matrix::cbind2(datamatrix[common_regions,], datamatrix_single[common_regions,])
        }
        rm(datamatrix_single);gc();
        if(is.null(annot_raw)){ annot_raw <- annot_single} else{ annot_raw <- rbind(annot_raw, annot_single)}
        rm(annot_single);gc();
      }
      incProgress(0.7, detail="saving raw data")
      save(datamatrix, annot_raw, file = file.path(init$data_folder, "datasets", input$new_dataset_name, "scChIP_raw.RData"))
      init$available_raw_datasets <- list.dirs(path = file.path(init$data_folder, "datasets"), full.names = FALSE, recursive = FALSE)
      init$datamatrix <- datamatrix
      init$annot_raw <- annot_raw
      
      updateActionButton(session, "compile_dataset", label="Added successfully", icon = icon("check-circle"))
    })
  })
  
  
  reactValues <- reactiveValues(annotColors_filtered = NULL)
  
  observeEvent(input$selected_raw_dataset, {  # load precompiled dataset and update coverage plot
    if(!is.null(input$selected_raw_dataset) & input$selected_raw_dataset != ""){
      print("Selecting precompiled dataset and update coverage plot ")
      
      myData = new.env()
      load(file.path(init$data_folder,"datasets", input$selected_raw_dataset, "scChIP_raw.RData"), envir = myData)
      init$datamatrix <- myData$datamatrix
      init$annot_raw <- myData$annot_raw
          
      }
  })
  
  observeEvent(input$selected_raw_dataset,{
    req(input$selected_raw_dataset)
    
    if(!is.null(input$selected_reduced_dataset)){
      delay(1500, {
        if(gsub(pattern ="_\\d*_\\d*_\\d*_\\w*","",input$selected_reduced_dataset) != input$selected_raw_dataset){
          
          showNotification(paste0("Warning : Selected raw dataset '",input$selected_raw_dataset,
                                  "' is different from selected reduced dataset '", input$selected_reduced_dataset,"'"),
                           duration = 5, closeButton = TRUE, type="warning")
        }
      })
    }
  })
  
  observeEvent(input$dim_reduction, {  # perform QC filtering and dim. reduction
    num_batches <- if(is.null(input$num_batches)) 0 else input$num_batches
    batch_names <- if(is.null(input$num_batches)) c() else sapply(1:input$num_batches, function(i){ input[[paste0('batch_name_', i)]] })
    batch_sels <- if(is.null(input$num_batches)) list() else lapply(1:input$num_batches, function(i){ input[[paste0('batch_sel_', i)]] })
    names(batch_sels) = batch_names
      
    annotationId <- annotation_id_norm()
    exclude_regions <- if(input$exclude_regions) setNames(read.table(
      input$exclude_file$datapath, header = FALSE, stringsAsFactors = FALSE), c("chr", "start", "stop")) else NULL
  
    callModule(Module_preprocessing_filtering_and_reduction, "Module_preprocessing_filtering_and_reduction", reactive({input$selected_raw_dataset}), reactive({input$min_coverage_cell}),
               reactive({input$min_cells_window}), reactive({input$quant_removal}), reactive({init$datamatrix}), reactive({init$annot_raw}),
               reactive({init$data_folder}),reactive({annotationId}), reactive({exclude_regions}), reactive({annotCol()}),reactive({input$do_batch_corr}),
                reactive({batch_sels}))
    init$available_reduced_datasets <- get.available.reduced.datasets()
    updateActionButton(session, "dim_reduction", label="Processed and saved successfully", icon = icon("check-circle"))
  })
  
  observeEvent(input$new_dataset_name, {  # reset label on actionButtion when new dataset is added
    updateActionButton(session, "compile_dataset", label="Compile dataset", icon = character(0))
  })
  
  observeEvent({input$selected_raw_dataset  # reset label on actionButtion when new filtering should be filtered
   input$min_coverage_cell
   input$quant_removal
   input$min_cells_window
   input$do_batch_corr}, {
   updateActionButton(session, "dim_reduction", label="Apply and save data set", icon = character(0))
  })
  
  reduced_dataset <- eventReactive(input$selected_reduced_dataset, { # load reduced data set to work with on next pages
    req(input$selected_reduced_dataset)

    init$available_filtered_datasets <- get.available.filtered.datasets(dataset_name(), input$selected_reduced_dataset)
    
    if(file.exists(file.path(init$data_folder, "datasets", dataset_name(), "correlation_clustering","Plots"))) 
      addResourcePath('Plots', file.path(init$data_folder, "datasets", dataset_name(), "correlation_clustering","Plots"))

    file_index <- match(c(input$selected_reduced_dataset), reduced_datasets())
    filename_sel <- file.path(init$data_folder, "datasets", init$available_reduced_datasets[file_index])
    myData = new.env()
    load(filename_sel, envir = myData)
    myData
    
  })

  observeEvent(input$selected_reduced_dataset, {  # load scExp, add colors, add correlation
    req(input$selected_reduced_dataset, reduced_dataset())
    
    updateSelectInput(session, "selected_raw_dataset", label = "Select data set :",
                      choices = init$available_raw_datasets,selected = gsub(pattern = "_\\d*_\\d*_\\d*_\\w*", "",
                                                                            input$selected_reduced_dataset))
    # Retrieve the scExp filtered
    scExp. = reduced_dataset()$scExp # retrieve filtered scExp
    scExp. = correlation_and_hierarchical_clust_scExp(scExp.)
    scExp(scExp.)
    rm(scExp.)
  })

  cell_cov_plot <- reactive({ggplot(cell_cov_df(), aes(x = coverage)) + 
      geom_histogram(color="black", fill="steelblue", bins = input$coverage_bins) +
      labs(x="read coverage per cell") +
      theme(panel.grid.major=element_blank(),panel.grid.minor=element_blank(), 
            panel.background=element_blank(), axis.line=element_line(colour="black"),
            panel.border=element_rect(colour="black", fill=NA))})
  
  output$cell_coverage <- plotly::renderPlotly( plotly::ggplotly(cell_cov_plot(), tooltip="Sample", dynamicTicks=T) )
  
  observeEvent(input$delete_dataset, {  # delete selected dataset
    withProgress(message='Deleting data set', value = 0, {
      incProgress(amount=0.5, detail=paste("..."))
      unlink(file.path(init$data_folder, "datasets", input$selected_delete_dataset), recursive=TRUE)
      init$available_raw_datasets <- list.dirs(path=file.path(init$data_folder, "datasets"), full.names=FALSE, recursive=FALSE)
      init$available_reduced_datasets <- get.available.reduced.datasets()
      incProgress(amount=0.5, detail=paste("... finished"))
    })
    showNotification("Data set successfully deleted.", duration=5, closeButton=TRUE, type="warning")
  })
  
  output$num_cell_after_QC_filt <- function(){
    req(reduced_dataset(), scExp())
    num_cell_after_QC_filt_scExp(scExp(),init$annot_raw)
  }
  
  output$table_QC_filt_box <- renderUI({
    if(!is.null(reduced_dataset())){
          column(12, align="left", tableOutput("num_cell_after_QC_filt"))
    }
  })
  
  observeEvent(input$selected_reduced_dataset,{if(nchar(input$selected_reduced_dataset)>0){unlocked$list$selected_reduced_dataset=T}else{for(i in names(unlocked$list)){unlocked$list[[i]]=F}}})
  observeEvent(unlocked$list,{able_disable_tab(("selected_reduced_dataset"),"pca_plots")}) 
  
  
  ###############################################################
  # 2. PCA
  ###############################################################
  
  output$pc_select_x <- renderUI({ selectInput("pc_select_x", "X",choices=paste0("Component_", c(1:15)), selected="Component_1") })
  output$pc_select_y <- renderUI({ selectInput("pc_select_y", "Y",choices=paste0("Component_", c(1:15)), selected="Component_2") })
  output$color_by <- renderUI({selectInput("color_by", "Color by", choices=annotCol()) })

  pca_plot <- reactive({
    req(scExp(), input$pc_select_x,input$pc_select_y,  input$color_by)

    p = plot_reduced_dim_scExp(scExp(),input$color_by, "PCA",
                               select_x = input$pc_select_x,
                               select_y = input$pc_select_y
    )
    unlocked$list$pca=T
    p
  })
  output$pca_plot <- plotly::renderPlotly( plotly::ggplotly(pca_plot(), tooltip="Sample", dynamicTicks=T) )
  
  tsne_plot <- reactive({
    req(scExp(), input$color_by)
    p = plot_reduced_dim_scExp(scExp(),input$color_by, "TSNE"
    )
    unlocked$list$tsne = T
    p
  })
  output$tsne_plot <- plotly::renderPlotly( plotly::ggplotly(tsne_plot(), tooltip="Sample", dynamicTicks=T) )
  
  umap_plot <- reactive({
    req(scExp(), input$color_by)
    p = plot_reduced_dim_scExp(scExp(),input$color_by, "UMAP"
    )
    p
  })
  output$umap_plot <- plotly::renderPlotly( plotly::ggplotly(umap_plot(), tooltip="Sample", dynamicTicks=T) )
  
  output$color_box <- renderUI({
    req(input$color_by)
    if(input$color_by != 'total_counts'){
      shinydashboard::box(title="Color settings", width = NULL, status = "success", solidHeader = T,
          column(6, htmlOutput("color_picker")),
          column(6 , br(), actionButton("col_reset", "Default colours", icon = icon("undo")),
                 br(), br(), actionButton("save_color", "Save colors & apply to all", icon = icon("save"))))
    }
  })
  
  observeEvent(input$col_reset, {
    cols <- gg_fill_hue(length(levels_selected()))
    lapply(seq_along(levels_selected()), function(i) {
      do.call(what="updateColourInput", args=list(session=session, inputId=paste0("color_", levels_selected()[i]), value=cols[i]))
    })
  })
  
  output$color_picker <- renderUI({
    #Color picker
    colsModif <- SummarizedExperiment::colData(scExp())[,c(input$color_by,paste0(input$color_by,"_color"))] %>% unique()
    lapply(seq_along(levels_selected()), function(i) {
      colourpicker::colourInput(inputId=paste0("color_", levels_selected()[i]),
                                label=paste0("Choose colour for ", levels_selected()[i]),
                                value=colsModif[i,paste0(input$color_by,"_color")], returnName=TRUE) ## Add ", palette = "limited"" to get selectable color panel       
    })
  })
  
  observeEvent(input$save_color, {  
    req(scExp(), input$color_by)
    color_df = get_color_dataframe_from_input(input,levels_selected(),input$color_by)
    scExp. = colors_scExp(scExp(),annotCol = annotCol(),color_by = input$color_by, color_df = color_df)
    scExp(scExp.)
    rm(scExp.)
  })
  
  levels_selected <- reactive({
    req(scExp(),input$color_by)
    levels_selected = SummarizedExperiment::colData(scExp())[,input$color_by] %>% unique() %>% as.vector()
  })

  observeEvent(unlocked$list,able_disable_tab(c("selected_reduced_dataset","pca","tsne"),"cor_clustering")) # if conditions are met, unlock tab Correlation Clustering
  
  
  ###############################################################
  # 3. Correlation clustering                                  ##
  ###############################################################
  
  corColors <- grDevices::colorRampPalette(c("royalblue","white","indianred1"))(256)

  hc_pca_plot <- reactive({
    req(scExp())
    plot_heatmap_scExp(scExp())
    unlocked$list$cor_clust_plot=TRUE;
  })

  output$corr_clust_pca_plot <- renderPlot(hc_pca_plot())
  
  output$download_cor_clust_plot <- downloadHandler(
    filename=function(){ paste0("correlation_clustering_", input$selected_reduced_dataset, ".png")},
    content=function(file){
      grDevices::png(file, width=1200, height=1400, res=300,pointsize = 8)
      plot_heatmap_scExp(scExp())
      grDevices::dev.off()

  })
  
  correlation_values <- reactiveValues(limitC=vector(length=500))
  corChIP <- reactive({ SingleCellExperiment::reducedDim(scExp(),"Cor") })
  z <- reactive({ matrix(sample(t(SingleCellExperiment::reducedDim(scExp(),"PCA"))), nrow=ncol(SingleCellExperiment::reducedDim(scExp(),"PCA"))) })
  thresh2 <- reactive({quantile(cor(z()), probs=seq(0,1,0.01))})
  limitC <- reactive({thresh2()[input$corr_threshold+1]})
  
  
  cell_cor_hist <- reactive({
    req(scExp())
    hist(corChIP(), prob=TRUE, col=alpha("steelblue", 0.8), breaks=50, ylim=c(0,4), main="Distribution of cell to cell correlation scores", xlab="Pearson Corr Scores")
    lines(density(corChIP()), col="blue", lwd=2)
    lines(density(cor(z())), col="black", lwd=2)
    abline(v=limitC(), lwd=2, col="red", lty=2)
    legend("topleft", legend=c("dataset", "randomized data", "correlation threshold"), col=c("blue", "black", "red"), lty=c(1, 1, 2), cex=0.8)
    
  })
  
  output$cell_cor_hist_plot <- renderPlot( cell_cor_hist() )
  
  output$download_cor_clust_hist_plot <- downloadHandler(
    filename=function(){ paste0("correlation_distribution_", input$selected_reduced_dataset, ".png")},
    content=function(file){
      grDevices::png(file, width=2000, height=1400, res=300)
      hist(corChIP(), prob=TRUE, col=alpha("steelblue", 0.8), breaks=50, ylim=c(0,4),cex=0.4, main="Distribution of cell to cell correlation scores", xlab="Pearson Corr Scores")
      lines(density(corChIP()), col="blue", lwd=2)
      lines(density(cor(z())), col="black", lwd=2)
      abline(v=limitC(), lwd=2, col="red", lty=2)
      legend("topleft", legend=c("dataset", "randomized data", "correlation threshold"), col=c("blue", "black", "red"), lty=c(1, 1, 2), cex=0.8)
      grDevices::dev.off()
  })
  
  observeEvent(input$filter_corr_cells, {  # retreiveing cells with low correlation score
    withProgress(message='Filtering correlated cells...', value = 0, {
      incProgress(amount=0.6, detail=paste("Filtering"))
      scExp_cf(filter_correlated_cell_scExp(scExp(), random_iter = 50, corr_threshold = input$corr_threshold,
                                            percent_correlation = input$percent_correlation))
      incProgress(amount=0.2, detail=paste("Saving"))
      data = list("scExp_cf" = scExp_cf())
      save(data, file = file.path(init$data_folder, "datasets", dataset_name(), "correlation_clustering",
                                              paste0(input$selected_reduced_dataset, "_", input$corr_threshold, "_",
                                                     input$percent_correlation, ".RData")))
      incProgress(amount=0.2, detail=paste("Finished"))
      init$available_filtered_datasets <- get.available.filtered.datasets(dataset_name(), input$selected_reduced_dataset)
      
      updateActionButton(session, "filter_corr_cells", label="Saved", icon = icon("check-circle"))
  
    })
  })
  
  observeEvent({input$selected_reduced_dataset  # reset label on actionButtion when new filtering should be filtered
    input$percent_correlation}, {
      updateActionButton(session, "filter_corr_cells", label="Filter & save", icon=character(0))
    })
  
  output$corr_clust_filter_plot <- renderPlot(
    plot_heatmap_scExp(scExp_cf())
    )
  
  
  
  output$download_cor_clust_filtered_plot <- downloadHandler(
    filename=function(){ paste0("correlation_clustering_filtered_", input$selected_reduced_dataset, ".png")},
    content=function(file){
      grDevices::png(file,  width=1200, height=1400, res=300,pointsize = 8)
      plot_heatmap_scExp(scExp_cf())
      grDevices::dev.off()
  })
  
  output$corr_filtered_hist <- renderUI({
    req(scExp_cf())
      column(12, align="left", plotOutput("corr_clust_filter_plot", height=500, width=500),
             downloadButton("download_cor_clust_filtered_plot", "Download image"), br(),
             tableOutput('num_cell_after_cor_filt')
             )
  })
  
  output$num_cell_before_cor_filt <- function()
  {
    req(scExp())
    num_cell_before_cor_filt_scExp(scExp())
  }
  
  output$num_cell_after_cor_filt <- function()
  {
    req(scExp(),scExp_cf())
    num_cell_after_cor_filt_scExp(scExp(),scExp_cf())
  }
  
  observeEvent(init$available_filtered_datasets, 
               {
                 if(length(init$available_filtered_datasets) > 0) {
                   unlocked$list$filtered_datasets = TRUE
                   } else {
                     unlocked$list$filtered_datasets = FALSE 
                     }
                 }
               )
  
  observeEvent(unlocked$list,
               {
                 able_disable_tab(c("selected_reduced_dataset","cor_clust_plot","filtered_datasets"),
                                  "cons_clustering")
                 }
               ) # if conditions are met, unlock tab Consensus Clustering on Correlated cells
  
  ###############################################################
  # 4. Consensus clustering on correlated cells
  ###############################################################
  
  filtered_datasets <- reactive({ if(is.null(init$available_filtered_datasets)) c() else gsub('.{6}$', '', basename(init$available_filtered_datasets)) })
  output$selected_filtered_dataset <- renderUI({ selectInput("selected_filtered_dataset", "Select data filtered by correlated cells (saved on previous page):", choices=filtered_datasets()) })
  output$filtered_data_selection_format <- renderText({"The name of the filtered dataset is composed of the following information: data set name, min percentage of reads per cell, 
    min percentage of cells to support a window, quantile of cell read counts to keep, correlation threshold, percent of cell correlation. To work on a different dataset or different preprocessing state, select it on the first page."})
  
  filtered_dataset <- observeEvent(input$selected_filtered_dataset, {
    if(!is.null(input$selected_filtered_dataset) & nchar(input$selected_filtered_dataset) > 5){
      myData = new.env()
      load(file.path(init$data_folder, "datasets", dataset_name(), "correlation_clustering", paste0(input$selected_filtered_dataset, ".RData")), envir = myData)
      scExp_cf(myData$data$scExp_cf)
    }
  })
  
  get_available_k <- function(){
    saved_clustFiles <- reactive({ list.files(path=file.path(init$data_folder, "datasets", dataset_name(), "correlation_clustering"), pattern=paste0(input$selected_filtered_dataset, '_affectation_k*'), full.names=FALSE) })
    k <- reactive({ gsub(".*_affectation_k(.+)\\.RData", "\\1", saved_clustFiles()) })
    isolate(k)
  }
  
  plotting_directory <- reactive({
    req( input$selected_filtered_dataset )
    if(!dir.exists(file.path(init$data_folder, "datasets", dataset_name(), "correlation_clustering","Plots")))
      dir.create(file.path(init$data_folder, "datasets", dataset_name(), "correlation_clustering","Plots"))
    file.path(init$data_folder, "datasets", dataset_name(), "correlation_clustering","Plots", input$selected_filtered_dataset)
  })
  
  clust <- reactiveValues(clust_pdf=NULL, cluster_consensus_png = NULL)
  
  observeEvent(input$selected_filtered_dataset, priority = 10, {
  
  cluster_consensus_files = list.files(plotting_directory(), pattern =  "icl.*\\.png")
  
  if(length(cluster_consensus_files) > 0){
    n = max(as.numeric(gsub("\\.png", "",gsub("icl", "", cluster_consensus_files))))
    cluster_consensus_file = cluster_consensus_files[grep(n, cluster_consensus_files)]
  } else {cluster_consensus_file = NULL}
  
  clust$clust_pdf <- file.path("Plots", input$selected_filtered_dataset, "consensus.pdf")
  clust$cluster_consensus_png <- file.path("Plots", input$selected_filtered_dataset,cluster_consensus_file)

  })
  
  observeEvent(input$selected_filtered_dataset, priority = 11, {
    print("Triggering consclust loading...")
    filename <- file.path(init$data_folder, "datasets", dataset_name(), "correlation_clustering",
                          paste0(input$selected_reduced_dataset, "_", input$corr_threshold, "_",
                                 input$percent_correlation, ".RData"))
      if(file.exists(filename)){
      myData = new.env()
      load(filename, envir = myData)
      scExp_cf(myData$data$scExp_cf)
      if("chromatin_group" %in% colnames(SummarizedExperiment::colData(scExp_cf()))){
        updateSelectInput(session, inputId = "nclust", label = "Select number of clusters:", choices=c(2:10),
                            selected = dplyr::n_distinct(SummarizedExperiment::colData(scExp_cf())$chromatin_group))
      }
    } else {
      NULL
    }
  })
  
  observeEvent(input$do_cons_clust, {
    withProgress(message='Performing consensus clustering...', value = 0, {
      incProgress(amount=0.4, detail=paste("part one"))

      scExp_cf(consensus_clustering_scExp(scExp_cf(), prefix = plotting_directory()))
      data = list("scExp_cf" = scExp_cf())
      save(data, file = file.path(init$data_folder, "datasets", dataset_name(), "correlation_clustering",
                                  paste0(input$selected_reduced_dataset, "_", input$corr_threshold, "_",
                                         input$percent_correlation, ".RData")))
      
      cluster_consensus_files = list.files(plotting_directory(), pattern = "icl.*\\.png")
      n = max(as.numeric(gsub("\\.png", "",gsub("icl", "", cluster_consensus_files))))
      cluster_consensus_file = cluster_consensus_files[grep(n, cluster_consensus_files)]

      clust$clust_pdf <- NULL  # needed in order to update the pdf output
      clust$clust_pdf <- file.path("Plots", input$selected_filtered_dataset, "consensus.pdf")
      clust$cluster_consensus_png <- NULL  # needed in order to update the pdf output
      clust$cluster_consensus_png <- file.path("Plots", input$selected_filtered_dataset, cluster_consensus_file)
    
      incProgress(amount=0.2, detail=paste("finished"))
    })
  })
  
 output$cons_clust_pdf <- renderUI({
    req(clust$clust_pdf)
    if(!is.null(clust$clust_pdf)) tags$iframe(style = "height:500px; width:100%", src = clust$clust_pdf)
    })

  output$cluster_consensus_png <- renderUI({
    
    tags$img(src = clust$cluster_consensus_png, height="50%", width="100%",.noWS = "after")
    
  })
  
  output$nclust_selection_info <- renderText({"After performing the clustering and checking the results for different numbers of clusters, select here the preferred number of clusters to make additional annotated plots."})

  observeEvent(input$choose_cluster, {
    if(is.null(scExp_cf())){
      print("scExp cf is null. Run consensus clustering first.")
    }
    else{
      if(! "consclust" %in% names(scExp_cf()@metadata)){
        showNotification("Could not find clustering results. Please make sure to perform the clustering before generating the final figures.", duration=7, closeButton=TRUE, type="warning")
      } else{
        withProgress(message='Preparing final figures...', value = 0, {
          incProgress(amount=0.2, detail=paste("Choosing cluster & recalculating tsne..."))
          scExp_cf(choose_cluster_scExp(scExp_cf(), as.integer(input$nclust)))
          incProgress(amount=0.4, detail = paste("Finished"))
          data = list("scExp_cf" = scExp_cf())
          save(data, file = file.path(init$data_folder, "datasets", dataset_name(), "correlation_clustering",
                                      paste0(input$selected_reduced_dataset, "_", input$corr_threshold, "_",
                                             input$percent_correlation, ".RData")))
          incProgress(amount=0.4, detail = paste("Saved"))
        })
      }
    }
  })
  
output$cons_clust_anno_plot <- renderPlot({
  if(! is.null(scExp_cf())){
    if("chromatin_group" %in% colnames(SummarizedExperiment::colData(scExp_cf()))){
      colors <- SummarizedExperiment::colData(scExp_cf())[scExp_cf()@metadata$hc_consensus_association$order,"chromatin_group_color"]
      heatmap(SingleCellExperiment::reducedDim(scExp_cf(),"ConsensusAssociation")[scExp_cf()@metadata$hc_consensus_association$order,],
              Colv = as.dendrogram(scExp_cf()@metadata$hc_consensus_association),
              Rowv = NA, symm = FALSE, scale="none", col = grDevices::colorRampPalette(c("white", "blue"))(100),
              na.rm = TRUE, labRow = F, labCol = F, mar = c(5, 5), main = paste("consensus matrix k=", input$nclust, sep=""),
              ColSideCol = colors)
    }
  }
    })
  
output$anno_cc_box <- renderUI({
  if(! is.null(scExp_cf())){
    if("chromatin_group" %in% colnames(SummarizedExperiment::colData(scExp_cf()))){
      shinydashboard::box(title="Annotated consensus clustering", width = NULL, status="success", solidHeader = T,
          column(12, align="left", plotOutput("cons_clust_anno_plot", height = 500, width = 500),
                 downloadButton("download_anno_cc_plot", "Download image")))
    }
  }
  })
  
  output$download_anno_cc_plot <- downloadHandler(
    filename = function(){ paste0("consensus_clustering_k", input$nclust, "_", input$selected_filtered_dataset, ".png")},
    content = function(file){
      grDevices::png(file, width = 1200, height = 800, res = 300)
      colors <- SummarizedExperiment::colData(scExp_cf())[scExp_cf()@metadata$hc_consensus_association$order,"chromatin_group_color"]
      heatmap(SingleCellExperiment::reducedDim(scExp_cf(),"ConsensusAssociation")[scExp_cf()@metadata$hc_consensus_association$order,],
              Colv = as.dendrogram(scExp_cf()@metadata$hc_consensus_association),
              Rowv = NA, symm = FALSE, scale="none", col = colorRampPalette(c("white", "blue"))(100),
              na.rm = TRUE, labRow = F, labCol = F, mar = c(5, 5), main = paste("consensus matrix k=", input$nclust, sep=""),
              ColSideCol = colors)
      grDevices::dev.off()
  })
  
  output$cor_clust_anno_plot <- renderPlot(plot_heatmap_scExp(scExp_cf(),name_hc = "hc_cor"))
  
  output$anno_corc_box <- renderUI({
    if(! is.null(scExp_cf())){
      if("chromatin_group" %in% colnames(SummarizedExperiment::colData(scExp_cf()))){
        shinydashboard::box(title="Annotated correlation clustering", width = NULL, status="success", solidHeader = T,
            column(12, align="left", plotOutput("cor_clust_anno_plot", height = 500, width = 500)),
            column(12, align="left", tableOutput("hcor_kable")),
            column(5,offset = 2, align="left", br(), htmlOutput("chi_info"),br()),
            column(12, align="left", downloadButton("download_anno_hc_plot", "Download image")))
      }
    }
  })
  
  output$download_anno_hc_plot <- downloadHandler(
    filename = function(){ paste0("hierarchical_clustering_k", input$nclust, "_", input$selected_filtered_dataset, ".png")},
    content = function(file){
      grDevices::png(file,  width = 1200, height = 1400, res = 300,pointsize = 8)
      plot_heatmap_scExp(scExp_cf(),name_hc = "hc_cor")
      grDevices::dev.off()
  })

    
  output$hcor_kable <- function(){
    req(scExp_cf())
    if(! is.null(scExp_cf())){
      if("chromatin_group" %in% colnames(SummarizedExperiment::colData(scExp_cf()))){
        num_cell_in_cluster_scExp(scExp_cf())
      } else{
        NULL
      }
    } else NULL
  }
 
  tsne_p_cf <- reactive({
    req(scExp_cf(), input$color_by_cf)
    p = plot_reduced_dim_scExp(scExp_cf(),input$color_by_cf, "TSNE",
                               select_x = "Component_1",
                               select_y = "Component_2")
    p
  })
  output$tsne_plot_cf <- plotly::renderPlotly( plotly::ggplotly(tsne_p_cf(), tooltip="Sample", dynamicTicks = T) )
  
  umap_p_cf <- reactive({
    req(scExp_cf(), input$color_by_cf)
    p = plot_reduced_dim_scExp(scExp_cf(),input$color_by_cf, "UMAP",
                               select_x = "Component_1",
                               select_y = "Component_2")
    p
  })
  output$umap_plot_cf <- plotly::renderPlotly( plotly::ggplotly(umap_p_cf(), tooltip="Sample", dynamicTicks = T) )
  
  levels_selected_cf <- reactive({
    req(scExp_cf(),input$color_by_cf)
    levels_selected_cf = SummarizedExperiment::colData(scExp_cf())[,input$color_by_cf] %>% unique() %>% as.vector()
  })
  
  output$plot_cf_box <- renderUI({
    if(! is.null(scExp_cf())){
      if("chromatin_group" %in% colnames(SummarizedExperiment::colData(scExp_cf())) ){
        shinydashboard::box(title="Annotated tSNE", width = NULL, status="success", solidHeader = T,
            column(6, align="left", selectInput("color_by_cf", "Color by", choices = c('sample_id', 'total_counts', 'chromatin_group','batch_id'))),
            column(12, align="left", plotly::plotlyOutput("tsne_plot_cf")),
            column(12, align="left", plotly::plotlyOutput("umap_plot_cf")))
      }
    }
  })
  
  output$color_box_cf <- renderUI({
    req(input$color_by_cf)
    if(! is.null(scExp_cf())){
      if("chromatin_group" %in% colnames(SummarizedExperiment::colData(scExp_cf()))){
        if(input$color_by_cf != 'total_counts'){
          shinydashboard::box(title="Color settings", width = NULL, status = "success", solidHeader = T,
              column(6, htmlOutput("color_picker_cf")),
              column(4 , br(), actionButton("col_reset_cf", "Default colours", icon = icon("undo")),
                     br(), br(), actionButton("save_color_cf", "Save colors & apply to all", icon = icon("save"))))
        }
      }
    }
  })

  observeEvent(input$save_color_cf, {  
    req(scExp_cf(), input$color_by_cf)
    color_df = get_color_dataframe_from_input(input,levels_selected_cf(), input$color_by_cf, "color_cf_")
    scExp_cf. = colors_scExp(scExp_cf(), annotCol = input$color_by_cf,
                             color_by = input$color_by_cf, color_df = color_df)
    scExp_cf(scExp_cf.)
    rm(scExp_cf.)
  })

  observeEvent(input$col_reset_cf, {
    cols <- gg_fill_hue(length(levels_selected_cf()))
    lapply(seq_along(levels_selected_cf()), function(i) {
      do.call(what="updateColourInput", args=list(session=session,
                                                  inputId=paste0("color_cf", levels_selected_cf()[i]), value=cols[i]))
    })
  })

  output$color_picker_cf <- renderUI({
    #Color picker
    colsModif <- as.data.frame(SummarizedExperiment::colData(scExp_cf()))[,c(input$color_by_cf,paste0(input$color_by_cf,"_color"))] %>% unique()
    lapply(seq_along(levels_selected_cf()), function(i) {
      colourpicker::colourInput(inputId=paste0("color_cf_", levels_selected_cf()[i]),
                                label=paste0("Choose colour for ", levels_selected_cf()[i]),
                                value=colsModif[i,paste0(input$color_by_cf,"_color")], returnName=TRUE) ## Add ", palette = "limited"" to get selectable color panel       
    })
  })
  
  observeEvent({
    input$selected_filtered_dataset
    scExp_cf()
    },
    {
      if(length(input$selected_filtered_dataset)>0 & !is.null(scExp_cf())){
        if("chromatin_group" %in% colnames(SummarizedExperiment::colData(scExp_cf()))){
          unlocked$list$affectation = T
        } else {
          unlocked$list$affectation = F
        }
      } else unlocked$list$affectation = F
    })
  
  observeEvent(unlocked$list, {able_disable_tab(c("selected_reduced_dataset","affectation"),c("peak_calling","diff_analysis"))}) 
  
  
  ###############################################################
  # 5. Peak calling [optional]
  ###############################################################
  
  output$peak_calling_info <- renderText({"This module is optional, but recommended in order to obtain more precise results for enrichment analysis. 
    Based on the BAM files for the samples in your project, peaks will be called using MACS2 [only work on unix systems] so that the counts can be mapped to the gene TSS more specifically.
    "})
  output$peak_calling_system <- renderText({
    platform = as.character(.Platform[1])
    if(length(grep("nix",platform,ignore.case = T)) ){
      macs2=""
      samtools=""
      try({
        macs2 = system2("which",args = "macs2",stdout = TRUE)
      })
      try({
        samtools = system2("which",args = "samtools",stdout = TRUE)
      })
      if(length(macs2)>0 & length(samtools)>0)
        return(paste0("<b>You are running on an ", platform, " OS.<br>Found MACS2 at ", macs2, ".<br>Found samtools at ", samtools,"</b>"))
      if(length(macs2)>0 & length(samtools)==0)
        return(paste0("<b>You are running on an ", platform, " OS.<br>Found MACS2 at ", macs2,".<br>Didn't find samtools ! Please install samtools or skip this step.</b>"))
      if(length(macs2)==0 & length(samtools)>0)
        return(paste0("<b>You are running on an ", platform, " OS.<br>Didn't find MACS2, please install MACS2 or skip this step.<br>Found samtools at ", samtools,"</b>"))
      if(length(macs2)==0 & length(samtools)==0)
        return(paste0("<b>You are running on an ", platform, " OS.<br>Didn't find MACS2, please install MACS2 or skip this step.<br>Didn't find samtools ! Please install samtools or skip this step.</b>"))
      
      } else {
      return(paste0("<b>You are running on a non unix system, peak calling is not available, you can move directly to differential analysis.</b> "))
    }
    })
  output$pc_k_selection <- renderText({
    paste0( "Number of clusters selected  = ", dplyr:::n_distinct(SummarizedExperiment::colData(scExp_cf())$chromatin_group))
  })
  
  output$bam_upload <- renderUI({
    req(scExp_cf())
    sample_ids <- unique(SummarizedExperiment::colData(scExp_cf())$sample_id)
    lapply(sample_ids, function(x){
      textInput(paste0('bam_', x), paste0('Full path to .bam file for sample ', x, ':'), value="/home/example/sample.bam")
    })
  })
  
  observeEvent(input$do_pc, {
    if(is.null(input$pc_k_selection) | input$pc_k_selection == ''){
      showNotification("No cluster number selected. It seems that you didn't select a clustering on the previous page, please go back and check.", duration = 7, closeButton = TRUE, type="warning")
    }else{
      withProgress(message='Performing enrichment analysis...', value = 0, {
        
        incProgress(amount = 0.1, detail = paste("Starting Peak Calling..."))
        dir.create(file.path(init$data_folder, "datasets", dataset_name(), "peaks"), showWarnings = FALSE)
        dir.create(file.path(init$data_folder, "datasets", dataset_name(), "peaks", paste0(input$selected_filtered_dataset, "_k", input$pc_k_selection)), showWarnings = FALSE)
        odir <- file.path(init$data_folder, "datasets", dataset_name(), "peaks", paste0(input$selected_filtered_dataset, "_k", input$pc_k_selection))
        sample_ids <- unique(SummarizedExperiment::colData(scExp_cf())$sample_id)
        inputBams <- as.character(unlist(sapply(sample_ids, function(x){ input[[paste0('bam_', x)]] })))

        checkBams <- sapply(inputBams, function(x){ if(file.exists(x)){ 0 } else { 
          showNotification(paste0("Could not find file ", x, ". Please make sure to give a full path including the file name."),
                           duration = 7, closeButton = TRUE, type="warning"); 1}  
        })
        incProgress(amount = 0.3, detail = paste("Running Peak Calling..."))
        if(sum(checkBams)==0){
          scExp_cf(subset_bam_call_peaks(scExp_cf(), odir, inputBams, as.numeric(input$pc_stat_value), annotation_id(), input$peak_distance_to_merge))
          data = list("scExp_cf" = scExp_cf())
          save(data, file = file.path(init$data_folder, "datasets", dataset_name(), "correlation_clustering",
                                      paste0(input$selected_reduced_dataset, "_", input$corr_threshold, "_",
                                             input$percent_correlation, ".RData")))
          pc$new <- Sys.time()
          updateActionButton(session, "do_pc", label="Finished successfully", icon = icon("check-circle"))
        }
        incProgress(amount = 0.3, detail = paste("Finished Peak Calling..."))
      })
    }
  })
  
  pc <- reactiveValues(new="")
  
  observeEvent({input$selected_filtered_dataset  # reset label on actionButtion when new peak calling should be performed
    input$pc_k_selection
    input$pc_stat
    input$pc_stat_value}, {
      pc$available_pc <- has_available_pc()
      updateActionButton(session, "do_pc", label="Start", icon = character(0))
  })
  
  has_available_pc <- reactive({
    if(!is.null(scExp_cf())){
      if("refined_annotation" %in% names(scExp_cf()@metadata) ){
        return(TRUE)
      } else return(FALSE)
    } else{
      return(FALSE)
    }
  })
  # available_pc_plots <- reactive({
  #   print(paste0("new peaks done: ", pc$new))
  #   fe <- sapply(c(1:input$pc_k_selection), function(i){file.exists(file.path(init$data_folder, "datasets", dataset_name(), "peaks", paste0(input$selected_filtered_dataset, "_k", input$pc_k_selection), paste0("C", i, "_model.r")))})
  #   which(fe==TRUE)
  # })

  # output$pc_plot_box <- renderUI({
  #   if(has_available_pc()){
  #     shinydashboard::box(title="Peak calling visualization", width = NULL, status="success", solidHeader = T,
  #         column(8, align="left", selectInput("pc_cluster","Select cluster (only those shown for which plots are available):", choices = paste0("C", available_pc_plots()))),
  #         column(12, align="left",
  #                plotOutput("peak_model_plot", height = 500, width = 500),
  #                plotOutput("cross_corr_plot", height = 500, width = 500)))
  #   }
  # })
  # 
  # pc_data_p <- reactive({ req(has_available_pc()); as.numeric(unlist(read.table(file.path(init$data_folder, "datasets", dataset_name(), "peaks", paste0(input$selected_filtered_dataset, "_k", input$pc_k_selection), paste0(input$pc_cluster, "_data_p.txt"))))) })
  # pc_data_m <- reactive({ req(has_available_pc()); as.numeric(unlist(read.table(file.path(init$data_folder, "datasets", dataset_name(), "peaks", paste0(input$selected_filtered_dataset, "_k", input$pc_k_selection), paste0(input$pc_cluster, "_data_m.txt"))))) })
  # pc_data_xcorr <- reactive({ req(has_available_pc()); as.numeric(unlist(read.table(file.path(init$data_folder, "datasets", dataset_name(), "peaks", paste0(input$selected_filtered_dataset, "_k", input$pc_k_selection), paste0(input$pc_cluster, "_data_xcorr.txt"))))) })
  # pc_data_ycorr <- reactive({ req(has_available_pc()); as.numeric(unlist(read.table(file.path(init$data_folder, "datasets", dataset_name(), "peaks", paste0(input$selected_filtered_dataset, "_k", input$pc_k_selection), paste0(input$pc_cluster, "_data_ycorr.txt"))))) })
  # peak_model_p <- reactive({
  #   req(has_available_pc())
  #   x <- seq.int((length(pc_data_p())-1)/2*-1,(length(pc_data_p())-1)/2)
  #   plot(x,pc_data_p(),type='l',col = c('red'),main='Peak Model',xlab='Distance to the middle',ylab='Percentage')
  #   lines(x,pc_data_m(),col = c('blue'))
  #   legend('topleft',c('forward tags','reverse tags'),lty = c(1,1,1),col = c('red','blue'))
  # })
  # output$peak_model_plot <- renderPlot(peak_model_p())
  # cross_corr_p <- reactive({
  #   req(has_available_pc())
  #   altd  <- c(297)
  #   plot(pc_data_xcorr(),pc_data_ycorr(),type='l',col = c('black'),main='Cross-Correlation',xlab='Lag between + and - tags',ylab='Correlation')
  #   abline(v = altd,lty = 2,col = c('red'))
  #   legend('topleft','alternative lag(s)',lty = 2,col='red')
  #   legend('topright','alt lag(s) : 297',bty='n')
  # })
  # output$cross_corr_plot <- renderPlot(cross_corr_p())
  
  
  ###############################################################
  # 6. Differential analysis
  ###############################################################
  
  output$diff_analysis_info <- renderText({"Differential analysis will be performed using the cluster assignment obtained on the Consensus clustering page. To use a different number of clusters, 
    go to this page and first perform the clustering, then select the preferred number of clusters in the box on the right in order to display and save the data. 
    It will then appear here for selection."})
  output$selected_k <- renderText({
    paste0( "Number of clusters selected  = ", dplyr:::n_distinct(SummarizedExperiment::colData(scExp_cf())$chromatin_group))
  })
  output$contrib_hist <- renderUI({ if(input$only_contrib_cells){ plotOutput("contrib_hist_p", height = 250, width = 500) }})
  output$contrib_hist_p <- renderPlot(contrib_hist_plot())
  contrib_hist_plot <- reactive({
    maxCons <- tapply(scExp_cf()@metadata$icl$itemConsensus$itemConsensus[scExp_cf()@metadata$icl$itemConsensus$k==input$selected_k],
                      scExp_cf()@metadata$icl$itemConsensus$item[scExp_cf()@metadata$icl$itemConsensus$k==input$selected_k], max)
    hist(maxCons, col="steelblue", breaks = 80, main="Max cluster contribution per cell", xlab="", ylab="number of cells")
    abline(v = input$contrib_thresh, lwd = 2, col="red", lty = 2)
    legend("topleft", legend = c("cluster contribution threshold"), col = c("red"), lty = c(2), cex = 0.8)
  })
  output$contrib_thresh <- renderUI({ if(input$only_contrib_cells){ sliderInput("contrib_thresh", "Select minimum cluster contribution for cells:", min = 0.6, max = 1, value = 0.9, step = 0.01) }})
  output$contrib_info <- renderUI({ if(input$only_contrib_cells){ textOutput("contrib_info_text") }})
  output$contrib_info_text <- renderText({
    total_cells <- length(unique(scExp_cf()@metadata$icl$itemConsensus$item[scExp_cf()@metadata$icl$itemConsensus$k==input$selected_k]))
    sel_cells <- length(unique(scExp_cf()@metadata$icl$itemConsensus$item[scExp_cf()@metadata$icl$itemConsensus$k==input$selected_k & scExp_cf()@metadata$icl$itemConsensus$itemConsensus >= input$contrib_thresh]))
    paste("Selected top", sel_cells, "cells out of", total_cells)
  })
  
  observeEvent(c(input$qval.th, input$cdiff.th, input$selected_k, input$de_type, input$selected_filtered_dataset), priority = 10,{

    if(!is.null(input$selected_filtered_dataset) && !is.null(input$qval.th) && !is.null(input$cdiff.th)){
      filename <- file.path(init$data_folder, "datasets", dataset_name(), "diff_analysis_GSEA",
                            paste0(input$selected_filtered_dataset, "_", input$selected_k,
                                   "_", input$qval.th, "_", input$cdiff.th, "_", input$de_type, ".RData"))
      
      if(file.exists(filename)){
        print("Loading Diff Analysis")
        myData = new.env()
        load(filename, envir = myData)
        scExp_cf(myData$data$scExp_cf)
      } else {
        NULL
      }
    }
    })
  
  observeEvent(input$do_wilcox, {  # perform differential analysis based on wilcoxon test
    withProgress(message='Performing differential analysis...', value = 0, {
      incProgress(amount = 0.2, detail = paste("Initializing DA"))
      if(batchUsed()) block = T else block = F
      scExp_cf(differential_analysis_scExp(scExp_cf(), de_type = input$de_type,
                                           cdiff.th = input$cdiff.th, qval.th = input$qval.th, block)) 
      incProgress(amount = 0.6, detail = paste("Finished DA"))
      data = list("scExp_cf" = scExp_cf())
      save(data, file = file.path(init$data_folder, "datasets", dataset_name(), "diff_analysis_GSEA",
                                  paste0(input$selected_filtered_dataset, "_", input$selected_k,
                                         "_", input$qval.th, "_", input$cdiff.th, "_", input$de_type, ".RData")))
  
      incProgress(amount = 0.2, detail = paste("Saving DA"))
    })
  })
  
  output$da_summary_box <- renderUI({
    if(!is.null(scExp_cf())){
      if(!is.null(scExp_cf()@metadata$diff)){
        shinydashboard::box(title="Number of differentially bound regions", width = NULL, status="success", solidHeader = T,
            column(5, align="left", br(), tableOutput("da_summary_kable")),
            column(7, align="left", plotOutput("da_barplot", height = 270, width = 250)),
            column(12, align="left", div(style = 'overflow-x: scroll', DT::dataTableOutput('da_table')), br()),
            column(4, align="left", downloadButton("download_da_barplot", "Download barplot")),
            column(4, align="left", downloadButton("download_da_table", "Download table")))
      }
    }
  })
  
  output$da_summary_kable <- function(){
    if(!is.null(scExp_cf())){
      if(!is.null(scExp_cf()@metadata$diff)){
        scExp_cf()@metadata$diff$summary %>%
          kableExtra::kable(escape = F, align="c") %>%
          kableExtra::kable_styling(c("striped", "condensed"), full_width = F)
      }
    }
  }
  output$da_barplot <- renderPlot({
    if(!is.null(scExp_cf())){
      if(!is.null(scExp_cf()@metadata$diff)){
        plot_differential_summary_scExp(scExp_cf())
      }
    }
  })
  
  output$download_da_barplot <- downloadHandler(
    filename = function(){ paste0("diffAnalysis_numRegions_barplot_", input$selected_filtered_dataset, "_", input$selected_k, "_", input$qval.th, "_", input$cdiff.th, "_", input$de_type, ".png")},
    content = function(file){
      grDevices::png(file, width = 800, height = 600, res = 150)
      plot_differential_summary_scExp(scExp_cf())
      grDevices::dev.off()
    })
  
  output$da_table <- DT::renderDataTable({
    if(!is.null(scExp_cf())){
      if(!is.null(scExp_cf()@metadata$diff)){
        table <- scExp_cf()@metadata$diff$res[, -c(1)]
        rownames(table) <- NULL
        for(i in seq(from = 0, to=(dim(table)[2]-8)/5, by = 1)){
          table[, (5*i+5)] <- round(table[, (5*i+5)], 3) #counts
          table[, (5*i+6)] <- round(table[, (5*i+6)], 3) #cdiff
        }
        table <- table[order(table$Rank.C1),]
        DT::datatable(table, options = list(dom='tpi'))
      }
    }
  })
  
  output$download_da_table <- downloadHandler(
    filename = function(){ paste0("diffAnalysis_data_", input$selected_filtered_dataset, "_", input$selected_k, "_", input$qval.th, "_", input$cdiff.th, "_", input$de_type, ".csv")},
    content = function(file){
      write.table(scExp_cf()@metadata$diff$res, file, row.names = F, quote = F, sep=",")
    })
  
  output$da_visu_box <- renderUI({
    if(!is.null(scExp_cf())){
      if(!is.null(scExp_cf()@metadata$diff)){
        shinydashboard::box(title="Visualization", width = NULL, status="success", solidHeader = T,
            column(4, align="left", selectInput("gpsamp", "Select cluster:", choices = scExp_cf()@metadata$diff$groups)),
            column(12, align="left", plotOutput("h1_prop", height = 300, width = 500),
                   plotOutput("da_volcano", height = 500, width = 500)),
            column(4, align="left", downloadButton("download_h1_plot", "Download histogram")),
            column(4, align="left", downloadButton("download_da_volcano", "Download volcano plot")))
      }
    }
  })
  
  output$h1_prop <- renderPlot({
    if(!is.null(scExp_cf())){
      if(!is.null(scExp_cf()@metadata$diff)){
        plot_differential_H1_scExp(scExp_cf(), input$gpsamp)
      }  
    }
  })
  
  output$download_h1_plot <- downloadHandler(
    filename = function(){ paste0("diffAnalysis_numRegions_barplot_", input$selected_filtered_dataset, "_", input$selected_k, "_", input$qval.th, "_", input$cdiff.th, "_", input$de_type, "_", input$gpsamp, ".png")},
    content = function(file){
      grDevices::png(file, width = 1000, height = 600, res = 300)
      plot_differential_H1_scExp(scExp_cf(), input$gpsamp)
      grDevices::dev.off()
  })
  
  output$da_volcano <- renderPlot({
    if(!is.null(scExp_cf())){
      if(!is.null(scExp_cf()@metadata$diff)){
        plot_differential_volcano_scExp(scExp_cf(),chromatin_group = input$gpsamp,
                                        cdiff.th = input$cdiff.th, qval.th = input$qval.th)
      }
    }
  })
  
  output$download_da_volcano <- downloadHandler(
    filename = function(){ paste0("diffAnalysis_numRegions_barplot_", input$selected_filtered_dataset, "_", input$selected_k, "_", input$qval.th, "_", input$cdiff.th, "_", input$de_type, "_", input$gpsamp, ".png")},
        content = function(file){
        grDevices::png(file, width = 900, height = 900, res = 300)
          plot_differential_volcano_scExp(scExp_cf(),chromatin_group = input$gpsamp,
                                          cdiff.th = input$cdiff.th, qval.th = input$qval.th)
        grDevices::dev.off()
    })
  
    observeEvent(unlocked$list, {
      able_disable_tab(c("selected_reduced_dataset","diff_my_res"),"enrich_analysis")
    }) 
    
    observeEvent(scExp_cf(), {
      if(!is.null(scExp_cf()@metadata$diff)){
        unlocked$list$diff_my_res = TRUE 
        } else{
          unlocked$list$diff_my_res = FALSE
        }
    }) 
    
  
  ###############################################################
  # 7. Enrichment analysis
  ###############################################################
  
  MSIG.classes <- reactive({
    myData = new.env()
    eval(parse(text = paste0("data(",annotation_id(),".MSIG.gs)")))
    classes = eval(parse(text = paste0("myData$",annotation_id(),".MSIG.gs$Class")))
    unique(classes)
  })

  annotFeat_long <- reactive({
    af = as.data.frame(rowData(scExp_cf()))
    af = tidyr::separate_rows(af, Gene,sep = ", ")
    af
  })
  
  output$enr_info <- renderText({"Enrichment will be performed based on the significant genes per cluster that were computed on the previous page. 
    Please make sure that you have run the differential analysis on the clustering that you prefer before running the enrichment analysis."})
  
  canUsePeaks <- reactive({
    print("Can usepeak calling exist ?")
    if(!is.null(scExp_cf())){
      if("refined_annotation" %in% names(scExp_cf()@metadata) ){
        return(TRUE)
      } else return(FALSE)
    } else{
      return(FALSE)
    }
    })
  
  output$use_peaks <- renderUI({
    if(canUsePeaks()){ checkboxInput("use_peaks", "use peak calling results to refine analysis", value = TRUE) }
  })
  
  enr <- reactiveValues(Both = NULL, Overexpressed = NULL, Underexpressed = NULL)
  
  GencodeGenes <- reactive({
    myData = new.env()
    eval(parse(text = paste0("data(",annotation_id(),".GeneTSS, envir = myData)")))
    as.character(unique(
      eval(parse(text = paste0("myData$",annotation_id(),".GeneTSS$gene")))
    ))
  })
  
  observeEvent(input$do_enrich, {
    withProgress(message='Performing enrichment analysis...', value = 0, {

      incProgress(amount = 0.3, detail = paste("Running GSEA"))
      scExp_cf(gene_set_enrichment_analysis_scExp(scExp_cf(), enrichment_qval = 0.01, qval.th = input$qval.th,
                                                  ref = annotation_id(), cdiff.th = input$cdiff.th,
                                                  peak_distance = 1000, use_peaks = input$use_peaks))
      incProgress(amount = 0.6, detail = paste("Finished GSEA"))
      data = list("scExp_cf" = scExp_cf() )
      save(data, file = file.path(init$data_folder, "datasets", dataset_name(), "diff_analysis_GSEA",
                                  paste0(input$selected_filtered_dataset, "_", input$selected_k,
                                         "_", input$qval.th, "_", input$cdiff.th, "_", input$de_type, ".RData")))
      incProgress(amount = 0.6, detail = paste("Saving GSEA"))
      
    })
  })
  
  output$enr_clust_sel <- renderUI({ 
    if(!is.null(scExp_cf())){
      if(!is.null(scExp_cf()@metadata$diff)){
      selectInput("enr_clust_sel", "Select cluster:", choices = scExp_cf()@metadata$diff$groups) 
      }
    }
    })
  
  output$enr_class_sel <- renderUI({shiny::checkboxGroupInput(inputId = "enr_class_sel", inline = T, label =  "Select classes to display:",
                                                              selected = MSIG.classes(), choiceNames = MSIG.classes(),
                                                              choiceValues = MSIG.classes())})
  
  output$all_enrich_table <- DT::renderDataTable({
    if(!is.null(scExp_cf())){
      if(!is.null(scExp_cf()@metadata$enr) && !is.null(input$enr_clust_sel) && !is.null(input$enr_class_sel)){
        table_enriched_genes_scExp(scExp_cf(),set = "Both", chromatin_group = input$enr_clust_sel, input$enr_class_sel)
      }
    }
  })
  
  output$over_enrich_table <- DT::renderDataTable({
    if(!is.null(scExp_cf())){
      if(!is.null(scExp_cf()@metadata$enr)){
        table_enriched_genes_scExp(scExp_cf(), set = "Overexpressed", chromatin_group = input$enr_clust_sel, input$enr_class_sel)
      }
    }
  })
  
  output$under_enrich_table <- DT::renderDataTable({
    if(!is.null(scExp_cf())){
      if(!is.null(scExp_cf()@metadata$enr)){
        table_enriched_genes_scExp(scExp_cf(), set = "Underexpressed", chromatin_group = input$enr_clust_sel, input$enr_class_sel)
      }
    }
  })
  
  output$download_enr_data <- downloadHandler(
    filename = paste(input$selected_filtered_dataset, input$selected_k, input$qval.th, input$cdiff.th, "enrichment_tables.zip", sep="_"),
    content = function(fname){
      fs <- c()
      for(i in 1:length(scExp_cf()@metadata$diff$groups)){
        if(!is.null(scExp_cf()@metadata$enr$Both[[i]])){
          filename <- paste0(scExp_cf()@metadata$diff$groups[i], "_significant_gene_sets.csv")
          fs <- c(fs, filename)
          write.table(scExp_cf()@metadata$enr$Both[[i]], file = filename, quote = FALSE, row.names = FALSE, sep=",")
        }
        if(!is.null(scExp_cf()@metadata$enr$Overexpressed[[i]])){
          filename <- paste0(scExp_cf()@metadata$diff$groups[i], "_enriched_gene_sets.csv")
          fs <- c(fs, filename)
          write.table(scExp_cf()@metadata$enr$Overexpressed[[i]], file = filename, quote = FALSE, row.names = FALSE, sep=",")
        }
        if(!is.null(scExp_cf()@metadata$enr$Underexpressed[[i]])){
          filename <- paste0(scExp_cf()@metadata$diff$groups[i], "_depleted_gene_sets.csv")
          fs <- c(fs, filename)
          write.table(scExp_cf()@metadata$enr$Underexpressed[[i]], file = filename, quote = FALSE, row.names = FALSE, sep=",")
        }
      }
      zip(zipfile = fname, files = fs)},
    contentType = "application/zip"
  )
  
  output$gene_sel <- renderUI({
    if(!is.null(scExp_cf())){
      if(!is.null(scExp_cf()@metadata$enr)){
        most_diff = scExp_cf()@metadata$diff$res %>% dplyr::select(ID,starts_with("qval."))
        most_diff[,"qval"] = Matrix::rowMeans(as.matrix(most_diff[,-1]))
        most_diff = dplyr::left_join(most_diff[order(most_diff$qval),], annotFeat_long(),by = c("ID"))
        most_diff = most_diff %>% dplyr::filter(!is.na(Gene)) 
        genes = base::intersect(most_diff$Gene,unique(GencodeGenes()))

        selectizeInput(inputId = "gene_sel", "Select gene:",options= list(maxOptions = 250),genes)
      }
    }
  })
  
  output$region_sel <- renderUI({
    req(input$gene_sel)
    print(input$gene_sel)
    print(head(annotFeat_long()$Gene))
    print(input$gene_sel %in% annotFeat_long()$Gene)
    print(which(annotFeat_long()$Gene==input$gene_sel))
    subset <- annotFeat_long()[which(annotFeat_long()$Gene==input$gene_sel), ]
    subset <- subset[order(subset$distance),]
    print(subset)
    regions <- paste0(subset$ID, " (distance to gene TSS: ", subset$distance, ")")
    selectInput("region_sel", "Select associated genomic region:", choices = regions)
  })
  

  gene_tsne_p <- reactive({
    req(input$gene_sel, input$region_sel)
    region <- strsplit(input$region_sel, " ")[[1]][1]
    if(region %in% rownames(scExp_cf())){
      p <- ggplot(as.data.frame(SingleCellExperiment::reducedDim(scExp_cf(), "TSNE")),
                  aes(x = "Component_1", y = "Component_2")) +
        geom_point(alpha = 0.5, aes(color = normcounts(scExp_cf())[region, ], shape = SummarizedExperiment::colData(scExp_cf())$chromatin_group)) +
        labs(color="norm. count for region", shape="Cluster", x="t-SNE 1", y="t-SNE 2") +
        theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
              panel.background = element_blank(), axis.line = element_line(colour="black"),
              panel.border = element_rect(colour="black", fill = NA)) +
        viridis::scale_color_viridis(direction=-1)
    }
  })
  
  output$gene_tsne_plot <- plotly::renderPlotly({
      req(input$gene_sel, input$region_sel)
      region <- strsplit(input$region_sel, " ")[[1]][1]
      if(region %in% rownames(scExp_cf())){
        plotly::ggplotly(gene_tsne_p(), tooltip="Sample", dynamicTicks = T)
      }
  })
  
  
  ###############################################################
  # 8. Close app
  ###############################################################
  
  observeEvent(input$close_and_save, {
    unlink(file.path("www", "images", "*"))
    unlink(file.path(".", "*.csv"))
    
    lapply(names(resourcePaths()), removeResourcePath)
    
    print("Thank you & see you next time !")
    js$closeWindow()
    stopApp()
  })
  
})
